---
title: "Breaking Changes in VS Insiders: LINQ vs Span Overload Surprises"
date: "2025-09-19"
description: "How subtle overload changes in Visual Studio Insiders broke my build ‚Äî and how I fixed them."
slug: "linq-vs-span-overload-surprise"
tags: ["C#", "dotnet", "Visual Studio", "VS Insiders", "Span", "LINQ"]
---

When I tried building some code in the **Visual Studio 2026 Insiders** build, something strange happened:  
**perfectly valid code in VS 2022 started failing.**

After digging in, I realized it wasn‚Äôt a bug in my code ‚Äî it was a change in **compiler overload resolution**.

---

## The LINQ vs Span Problem

Consider this code:

```csharp
var endPart = request.SearchTerm.Split(" ")
                                .Reverse()
                                .FirstOrDefault();
```

### ‚úÖ In Visual Studio 2022
- `Split()` returns `string[]`.
- `.Reverse()` resolves to `Enumerable.Reverse(IEnumerable&lt;T&gt;)`, which **returns IEnumerable&lt;T&gt;**.
- `.FirstOrDefault()` works.

### ‚ùå In Visual Studio 2026 Insiders
- `string[]` is implicitly convertible to `Span<string>`.
- `.Reverse()` resolves to `MemoryExtensions.Reverse(Span<T>)`, which **returns void** (in-place).
- `.FirstOrDefault()` fails to compile.

---

## Fix 1 ‚Äì Be Explicit with LINQ

Force the LINQ overload:

```csharp
var endPart = request.SearchTerm
                        .Split(' ')
                        .AsEnumerable()
                        .Reverse()
                        .FirstOrDefault();
```

---

## Fix 2 ‚Äì Use LastOrDefault

Since I just needed the **last token**, this is cleaner:

```csharp
var parts   = request.SearchTerm
                .Split(' ', StringSplitOptions.RemoveEmptyEntries);
var endPart = parts.LastOrDefault();
```

---

## RedisValue Case

Another place that broke:

```csharp
return JsonSerializer
        .Deserialize<RgsMapLineModel>(result);
```

In VS 2022, it compiled fine.  
But in Insiders, `result` is a `RedisValue` (struct), not directly supported by `JsonSerializer`.

‚úÖ Fix:

```csharp
return JsonSerializer
        .Deserialize<RgsMapLineModel>(result
                                .ToString());
```

---

## Lessons Learned

- **Implicit conversions to Span** are picked up eagerly in the new compiler.
- Be explicit with `.AsEnumerable()` or use `Enumerable.Reverse()` if you want LINQ.
- For structs like `RedisValue`, always convert before passing to APIs like `JsonSerializer`.

---

## Closing Thoughts

While this feels like a breaking change, it‚Äôs actually the compiler **preferring high-performance APIs** (`Span<T>`). That‚Äôs good for performance, but it means our code needs to be explicit about intent.  

If you‚Äôre experimenting with **VS Insiders**, watch out for these tweaks!

> A good read : [Understanding C# overload-resolution](https://learn.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/10.0/csharp-overload-resolution)

## Last Note
### Why does the compiler prefer `Span<T>`?

You might wonder why the new compiler prefers `Span<T>` overloads over `string[]` and LINQ.  
The reason is performance: `Span<T>` lets you work with slices of arrays and strings **without extra allocations**.

### Advantages of `Span<T>`
- **No extra memory allocations** ‚Üí avoids creating new arrays when slicing strings.  
- **Safer than pointers** ‚Üí provides bounds checking while working with memory directly.  
- **Faster iteration** ‚Üí direct access without LINQ‚Äôs deferred execution overhead.  

### Example

```csharp
// Traditional LINQ
var words = text.Split(' ');
var last  = words.LastOrDefault();

// With Span<T>
ReadOnlySpan<char> span = text.AsSpan();
int idx = span.LastIndexOf(' ');
var lastWord = idx >= 0 ? span.Slice(idx + 1).ToString() : text;
```
The second approach avoids creating an intermediate string[] entirely.

üëâ I‚Äôll explore the power of Span&lt;T&gt; in depth (and when not to use it) in a follow-up blog.

Peace... üçÄ
