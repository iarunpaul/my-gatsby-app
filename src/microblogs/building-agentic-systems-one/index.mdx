---
title: "Building Agentic Systems with MCP in .NET â€“ Getting Started"
description: "Kickstart your journey with Model Context Protocol (MCP) in .NET by learning what MCP is, why it matters, and building your first MCP servers."
date: "2025-09-01"
slug: "null"
tags: ["dotnet", "mcp", "ai", "agents", "llm", "csharp"]
series: "Building Agentic Systems with MCP in .NET"
hero_image: "./Part1-Title.png"
hero_image_alt: "Part1 - Building Agentic Systems with MCP in .NET"
hero_image_credit_text: "ChatGPT & Dall-E by OpenAI"
hero_image_credit_link: "https://openai.com/index/dall-e-3/"
---

# Building Agentic Systems with MCP in .NET â€“ Getting Started

The AI ecosystem is evolving rapidly. Large Language Models (LLMs) are no longer just text predictorsâ€”they can reason, analyze, and even take actions.  
But hereâ€™s the challenge: **how do we let these models safely and consistently interact with real-world data and tools?**

Thatâ€™s where **MCP â€“ Model Context Protocol** comes in.  
This blog series will walk you through **building agentic systems with MCP in .NET**, starting from the basics and ending with real-world agent workflows powered by multiple LLMs.  

---

## ğŸ¯ What This Series Covers

Hereâ€™s the roadmap:

- **Episode 1 (this post):**  
  What is MCP, how they differ from APIs, How does MCP actually work, and building a simple first MCP server in .NET and connect and call using a MCP Inspector.

- **Episode 2:**  
  Lets use llms and how they easily interact with standard MCP tools and enhance MCP workflows.

- **Episode 3:**  
  Going Agentic â€“ using multiple agents with single responsibility.

- **Episode 4:**  
  Multiple LLMs, multiple modes â€“ picking the right model for each agentâ€™s task.

- **Episode 5:**  
  Real-world use case â€“ connecting booking data, stock availability, and market APIs to build a forecasting system.

By the end, youâ€™ll have a working understanding of MCP **and** a multi-agentic system you can adapt to your own projects.

---
## Part 1: How MCP Works

Welcome to the first episode of our series **â€œBuilding Agentic Systems with MCP in .NET.â€**  

In this part we wonâ€™t even touch LLMs yet. Instead, weâ€™ll answer:  
ğŸ‘‰ **How does MCP actually work?**  

Weâ€™ll:  
- Explain the role of an **MCP Server** and **MCP Client**.  
- Compare MCP with a typical API.  
- Build a simple server in .NET.  
- Use **MCP Inspector** as a client to connect, discover, and call tools.  
- Understand the **flow of messages**.  

By the end of this post, youâ€™ll know the **mechanics of MCP**. Then in Part 2, weâ€™ll talk about **why** MCP exists (and how LLMs fit into the story).

---

## ğŸ”„ MCP in a Nutshell

At its core, MCP is just a **protocol** for structured communication between:

- **Server** â†’ Exposes â€œtoolsâ€ (functions) you want others to call.  
- **Client** â†’ Connects to the server, discovers the tools, and calls them.  

Think of it like **JSON-RPC with conventions**:
- Tools are described with **schemas** (inputs & outputs).  
- Clients donâ€™t need to read documentationâ€”they can query the server to learn what it supports.  
- The transport can be STDIO (pipes), sockets, or HTTP.  

---

## ğŸ†š MCP vs. a Typical API
<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>REST/GraphQL API</th>
            <th>MCP Protocol</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Discovery</strong></td>
            <td>Requires docs/Swagger/OpenAPI</td>
            <td>Built-in: client asks server</td>
        </tr>
        <tr>
            <td><strong>Transport</strong></td>
            <td>HTTP/HTTPS only</td>
            <td>STDIO, WebSocket, HTTP, etc.</td>
        </tr>
        <tr>
            <td><strong>Schema</strong></td>
            <td>Optional / external spec</td>
            <td>Always part of the protocol</td>
        </tr>
        <tr>
            <td><strong>LLM-friendly</strong></td>
            <td>Needs glue code / adapters</td>
            <td>Native design (structured I/O)</td>
        </tr>
        <tr>
            <td><strong>Caller</strong></td>
            <td>Any app with HTTP</td>
            <td>Any MCP-aware client (LLM, IDE, inspector)</td>
        </tr>
    </tbody>
</table>

ğŸ’¡ The **key difference** is: with MCP, **clients discover and adapt automatically**.  
No hand-coded integrations, no brittle JSON responses.  

---

## âš™ï¸ Setting Up the Project

Weâ€™ll use the **official preview SDK** from Microsoft: `ModelContextProtocol`.

### Create a new console app
```bash
dotnet new console -n McpDemo
cd McpDemo
```
Add the packages
```bash
dotnet add package Microsoft.Extensions.Hosting --version 9.0.3
dotnet add package ModelContextProtocol --version 0.2.0-preview.1
dotnet add package System.Text.Json --version 9.0.3
```
Your `.csproj` will look like this:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.3" />
    <PackageReference Include="ModelContextProtocol" Version="0.2.0-preview.1" />
    <PackageReference Include="System.Text.Json" Version="9.0.3" />
  </ItemGroup>
</Project>
```
ğŸ‘‹ Writing Your First MCP Server

Edit `Program.cs` like this:

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Server;
using System.ComponentModel;

var builder = Host.CreateApplicationBuilder(args);

// log to stderr (MCP clients expect logs here)
builder.Logging.AddConsole(o => o.LogToStandardErrorThreshold = LogLevel.Trace);

// register the MCP server with STDIO transport
builder.Services
    .AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly(); // reflection scan for [McpServerTool] methods

await builder.Build().RunAsync();

// ---------------- TOOLS ----------------

// Tools are plain static methods with attributes.
[McpServerToolType]
public static class HelloTools
{
    [McpServerTool, Description("Greets the supplied name.")]
    public static string Hello([Description("Name to greet")] string name = "world")
        => $"Hello MCP, {name}!";
}
```
ğŸ§­ Testing with MCP Inspector
Instead of writing a client, letâ€™s use the official Inspector to act as one.

Install & run Inspector
```bash
npx @modelcontextprotocol/inspector@latest
```
It opens a local UI in your browser.

Connect to your .NET server

In the Inspector UI:

Transport â†’ 
```arduino
STDIO
```

Command â†’ 
```arduino
dotnet
```

Arguments â†’

```arduino
run
```
Click Connect

Explore tools

Click List Tools in Inspector.

You should see:

> Hello (from our HelloTools class)

Click the tool, and Inspector shows its input schema (name).

Call a tool 

Enter input:

> name: world

Click Run Tool.

Expected output:

```
Hello MCP, world!
```
ğŸ‰ Congrats, you just built your first MCP server and client interaction.

## ğŸ§  Understanding the Flow
Hereâ€™s what happened:

Inspector (the client) connected to your server via STDIO.

Client asked: â€œWhat tools do you support?â€ â†’ Server responded with schemas.

Client presented the tool in a UI form.

You provided inputs.

Inspector called the tool via MCP messages.

Server returned a structured JSON response.

ğŸ‘‰ Unlike a REST API, the client didnâ€™t need hardcoded knowledge of your server.
It discovered everything dynamically.

## ğŸ‰ Whatâ€™s Next?
Now you know how MCP works:

- Servers expose tools.

- Clients discover and call them.

- The difference from APIs is in built-in discovery, schema, and transport flexibility.

But the **why** is still missing.
- **Why** *should you care about MCP* when you already have APIs?
- **Why** is it *particularly exciting for LLMs*?

ğŸ‘‰ Thatâ€™s what weâ€™ll cover in Part 2:

- **Why** MCP exists

- **How** it unlocks LLM integration

- **A demo** where we connect your MCP server to an LLM client

Stay tunedâ€”it gets fun when the AI enters the scene! ğŸš€

Happy coding ğŸ€!