name: Deploy LinkedIn MCP Server to Azure Container Apps

on:
  push:
    branches:
      - main
    paths:
      - 'mcp-servers/**'
      - '.github/workflows/azure-mcp-server.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'mcp-servers/**'
  workflow_dispatch:

env:
  AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY_LOGIN }}
  CONTAINER_NAME: linkedin-mcp-server
  RESOURCE_GROUP: Pollys
  CONTAINER_APP_NAME: linkedin-mcp-server
  CONTAINER_APP_ENVIRONMENT: linkedin-mcp-env

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.AZURE_CONTAINER_REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.CONTAINER_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./mcp-servers/linkedin-real
        file: ./mcp-servers/linkedin-real/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create or Update Container App Environment
      run: |
        # Check if Container App Environment exists
        if ! az containerapp env show --name ${{ env.CONTAINER_APP_ENVIRONMENT }} --resource-group ${{ env.RESOURCE_GROUP }} &> /dev/null; then
          echo "Creating Container App Environment..."
          az containerapp env create \
            --name ${{ env.CONTAINER_APP_ENVIRONMENT }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --location "East US"
        else
          echo "Container App Environment already exists"
        fi

    - name: Deploy to Azure Container Apps
      run: |
        # Get the image URL with latest tag
        IMAGE_URL="${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.CONTAINER_NAME }}:latest"
        
        # Check if Container App exists
        if az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &> /dev/null; then
          echo "Updating existing Container App..."
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image $IMAGE_URL \
            --set-env-vars \
              MCP_SERVER_PORT=8001 \
              MCP_SERVER_HOST=0.0.0.0 \
              LINKEDIN_EMAIL="${{ secrets.LINKEDIN_EMAIL }}" \
              LINKEDIN_PASSWORD="${{ secrets.LINKEDIN_PASSWORD }}" \
              ANTHROPIC_API_KEY="${{ secrets.ANTHROPIC_API_KEY }}" \
              LINKEDIN_HEADLESS=true \
              LINKEDIN_TIMEOUT=30 \
              DEBUG=false \
              LOG_LEVEL=info \
              ALLOWED_ORIGINS="https://gray-pebble-0a500ec00.azurestaticapps.net,https://web.iarunpaul.com"
        else
          echo "Creating new Container App..."
          az containerapp create \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --environment ${{ env.CONTAINER_APP_ENVIRONMENT }} \
            --image $IMAGE_URL \
            --target-port 8001 \
            --ingress external \
            --min-replicas 0 \
            --max-replicas 3 \
            --cpu 0.5 \
            --memory 1Gi \
            --env-vars \
              MCP_SERVER_PORT=8001 \
              MCP_SERVER_HOST=0.0.0.0 \
              LINKEDIN_EMAIL="${{ secrets.LINKEDIN_EMAIL }}" \
              LINKEDIN_PASSWORD="${{ secrets.LINKEDIN_PASSWORD }}" \
              ANTHROPIC_API_KEY="${{ secrets.ANTHROPIC_API_KEY }}" \
              LINKEDIN_HEADLESS=true \
              LINKEDIN_TIMEOUT=30 \
              DEBUG=false \
              LOG_LEVEL=info \
              ALLOWED_ORIGINS="https://gray-pebble-0a500ec00.azurestaticapps.net,https://web.iarunpaul.com"
        fi

    - name: Get Container App URL
      id: get-url
      run: |
        FQDN=$(az containerapp show \
          --name ${{ env.CONTAINER_APP_NAME }} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query properties.configuration.ingress.fqdn \
          --output tsv)
        echo "CONTAINER_APP_URL=https://$FQDN" >> $GITHUB_OUTPUT
        echo "Container App URL: https://$FQDN"

    - name: Test Container App Health
      run: |
        echo "Testing Container App health..."
        sleep 30  # Wait for container to start
        
        # Test health endpoint
        HEALTH_URL="${{ steps.get-url.outputs.CONTAINER_APP_URL }}/health"
        echo "Testing: $HEALTH_URL"
        
        # Retry health check up to 5 times
        for i in {1..5}; do
          if curl -f -s "$HEALTH_URL" > /dev/null; then
            echo "✅ Health check passed on attempt $i"
            curl -s "$HEALTH_URL" | jq .
            break
          else
            echo "⏳ Health check failed on attempt $i, retrying..."
            sleep 10
          fi
          
          if [ $i -eq 5 ]; then
            echo "❌ Health check failed after 5 attempts"
            exit 1
          fi
        done

    - name: Test MCP Endpoints
      run: |
        BASE_URL="${{ steps.get-url.outputs.CONTAINER_APP_URL }}"
        
        echo "Testing MCP Status endpoint..."
        curl -s "$BASE_URL/api/mcp/status" | jq .
        
        echo "Testing MCP Connect endpoint..."
        curl -s -X POST "$BASE_URL/api/mcp/connect" | jq .

    - name: Update Deployment Status
      if: success()
      run: |
        echo "🎉 LinkedIn MCP Server deployed successfully!"
        echo "📡 Server URL: ${{ steps.get-url.outputs.CONTAINER_APP_URL }}"
        echo "🔗 Health Check: ${{ steps.get-url.outputs.CONTAINER_APP_URL }}/health"
        echo "📊 MCP Status: ${{ steps.get-url.outputs.CONTAINER_APP_URL }}/api/mcp/status"
        
        # Create deployment summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## 🚀 LinkedIn MCP Server Deployment
        
        ### ✅ Deployment Successful
        
        **Server URL:** ${{ steps.get-url.outputs.CONTAINER_APP_URL }}
        
        **Available Endpoints:**
        - Health Check: \`GET /health\`
        - MCP Status: \`GET /api/mcp/status\`
        - MCP Connect: \`POST /api/mcp/connect\`
        - LinkedIn Feed: \`GET /api/linkedin/feed\`
        - LinkedIn Jobs: \`GET /api/linkedin/jobs\`
        - LinkedIn Summary: \`POST /api/linkedin/summary\`
        
        **Next Steps:**
        1. Update your Gatsby site's environment variables
        2. Set \`GATSBY_MCP_SERVER_URL=${{ steps.get-url.outputs.CONTAINER_APP_URL }}\`
        3. Test the integration from your frontend
        
        **Azure Resources:**
        - Resource Group: \`${{ env.RESOURCE_GROUP }}\`
        - Container App: \`${{ env.CONTAINER_APP_NAME }}\`
        - Environment: \`${{ env.CONTAINER_APP_ENVIRONMENT }}\`
        EOF

  cleanup-on-failure:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    permissions:
      contents: read
      id-token: write

    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Cleanup Failed Deployment
      run: |
        echo "🧹 Cleaning up failed deployment..."
        
        # Check if container app exists and remove if in failed state
        if az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &> /dev/null; then
          PROVISIONING_STATE=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query properties.provisioningState \
            --output tsv)
          
          if [ "$PROVISIONING_STATE" = "Failed" ]; then
            echo "Removing failed container app..."
            az containerapp delete \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --yes
          fi
        fi

